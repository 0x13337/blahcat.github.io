---
layout: post
title: First exploit in Windows Kernel (HEVD)
author: hugsy
author_twitter: _hugsy_
author_email: hugsy@[RemoveThisPart]blah.cat
author_github: hugsy
header-img: img/win-kernel-debug/win8-setup-kernel-mode.png
tags: windows kernel debugging exploit stack-overflow
---

Hi there!

This post is the third chapter of this series, where we dive into Windows
kernel. The previous posts introduced respectively how to painlessly setup a
Windows exploit lab, then how to create a custom shellcode for the kernel to
execute.

So now we need vulnerabilities to get control of the program counter (RIP since
we only focus on x64). For that, we'll use the most awesome **Extremely
Vulnerable Driver**.


# Setup

[Extremely Vulnerable Driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver) is
a Windows driver for x86 and x64 created by
the [HackSys team](http://hacksys.vfreaks.com/) (huge props!). Once injected
into Windows, this driver purposely offers several types of vulnerabilities, to
help us practice on them and/or assist us developing new exploitation techniques.

## On the Windows 8.1 x64 debuggee VM

Download and unzip in the Windows 8.1 x64 debuggee VM:

 - [OSR Driver Loader](https://www.osronline.com/article.cfm?article=157)
 - [HackSys Extremely Vulnerable Driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/releases/download/v1.20/HEVD.1.20.zip)

Then simply run the `OSR Driver Loader` and register the AMD64 version of
`HEVD.sys`.

{% include image.html src="/img/win-kernel-debug/register-hevd.png" %}

You can then start the service.


## On the Windows debugger VM

Retrieve the AMD64 directory of HEVD, as it contains the PDB symbols that WinDBG
will use for extra information, and copy the PDB into a `hevd.pdb` directory
located within one of the path defined in the `_NT_SYMBOL_PATH` environment
variable. For example like this (you might need to adjust to your own
configuration):

{% highlight text %}
C:>  set | find "_NT_SYMBOL_PATH"
_NT_SYMBOL_PATH=SRV*C:\symbols*http://msdl.microsoft.com/download/symbols;
C:> mkdir C:\symbols\hevd.pdb
C:> mkdir C:\syms\hevd.pdb\8F6551A1E31E4F65B536C8DCB40F999B1
C:> xcopy %HOMEPATH%\Desktop\AMD64\*.pdb C:\symbols\hevd.pdb\8F6551A1E31E4F65B536C8DCB40F999B1
{% endhighlight %}

We can use WinDBG to check that:

  * the HEVD driver is properly loaded:

{% highlight text %}
kd> lm m HEVD
start             end                 module name
fffff800`c1e39000 fffff800`c1e42000   HEVD       (deferred)
{% endhighlight %}

  * WinDBG can retrieve its symbols:

{% highlight text %}
kd> .sympath
Symbol search path is: srv*c:\symbols*http://msdl.microsoft.com/download/symbols

kd> x HEVD!*
fffff800`c1e3c110 HEVD!g_UseAfterFreeObject = 0x00000000`00000000
fffff800`c1e3c108 HEVD!__security_cookie_complement = 0xffff07ff`3e1c34a0
fffff800`c1e3b368 HEVD!$xdatasym = 0x01 ''
fffff800`c1e3b388 HEVD!$xdatasym = 0x01 ''
fffff800`c1e3c000 HEVD!HotPatchBuffer = struct _PATCH_BUFFER
[...]
{% endhighlight %}

We're good to go, let's dive in!


# Reverse-Engineering HEVD.sys

Although the
[source code](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/tree/master/Driver) of
the entire driver is freely accessible, going black-box reversing (i.e. without
any source code) is a good practice for real-life bug hunting. Moreover, the
driver is well written, no obfuscation/packing in place, and the symbols
are provided, to greatly improve the reversing process.

## Spotting a vulnerability

Any Windows driver must at least define an entry point by which Windows can load
it. This is done with
the
[DriverEntry](https://msdn.microsoft.com/en-us/library/windows/hardware/ff544113(v=vs.85).aspx)
whose signature is as follow:

{% highlight c %}
NTSTATUS DriverEntry(
  _In_ struct _DRIVER_OBJECT *DriverObject,
  _In_ PUNICODE_STRING       RegistryPath
)
{% endhighlight %}

WinDBG confirms that immediately:

{% highlight text %}
kd> x HEVD!DriverEntry
fffff800`c1e41008 HEVD!DriverEntry (struct _DRIVER_OBJECT *, struct _UNICODE_STRING *)`
{% endhighlight %}

By checking this function in IDA Pro, we spot immediately that the driver is
creating a device called `\Device\HackSysExtremeVulnerableDriver` via the
routine
[`IoCreateDevice`](https://msdn.microsoft.com/en-us/library/windows/hardware/ff548397(v=vs.85).aspx),
with a `DeviceType` set
as
[`FILE_DEVICE_UNKNOWN`](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/specifying-device-types) -
or 0x22.

![DriverEntry in IDA](/img/win-kernel-debug/hevd-stack-overflow-ida-driver-entry.png)

Then the `DriverObject` gets affects with several including the IOCTL
handler, called `IrpDeviceIoCtlHandler`.
This function dispatches IOCTL requests done from user-land to the HEVD
driver. To identify an IOCTL, a specific code is affected to it, that IDA
identifies immediately for us, by following the flow graph:

{%include image.html src="img/win-kernel-debug/hevd-stack-overflow-ida-ioctl-1.png"%}

In our first exploitation, we want to reach the `StackOverflowIoctlHandler`, and
therefore need to send
a
[`DeviceIoControl()`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363216(v=vs.85).aspx)
with a code set to 0x222003.

*_Note_*: to reach the other vulnerabilities, all we'll need to do then is
simply change the `dwIoControlCode` value of our request.

# Debugging

useful commands

{% highlight text %}
# verbose debug output
ed nt!Kd_Default_Mask 8
!sym noisy

# break undefined
bu HEVD!IrpDeviceIoCtlHandler+1c
bu HEVD!IrpDeviceIoCtlHandler+134
{% endhighlight %}

# Final wrap-up


{%include image.html src="/img/win-kernel-debug/hevd-stack-overflow-exploit.png"%}

w00t !

# Related links

 * [WinDBG cheatsheet](http://windbg.info/doc/1-common-cmds.html)
 * [Rootkit - Subverting the Windows Kernel](https://www.amazon.com/Rootkits-Subverting-Windows-Greg-Hoglund-ebook/dp/B000OZ0N76)
